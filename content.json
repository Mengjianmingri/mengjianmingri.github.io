{"pages":[],"posts":[{"title":"linux 下复习c语言编程日记(长期更新)","text":"自从找到工作之后就一直计划着把这四年大学里没好好学的或者忘却了的课程复习一遍,那么就从C开始吧: 2020.04.04 操作系统: ubuntu18.04 编辑: gedit 编译: gcc 1234mkdir myC #创建一个文件夹来作为练习C语言的根目录mkdir test01 #创建第一个测试文件夹touch main.c #创建一个.c文件gedit ./main.c # 使用gedit来编辑这个.c文件 在打开的编辑窗口里写入: 12345#include &lt;stdio.h&gt;int main(){ puts(\"你好!\"); return 0;} ctrl s 保存编辑后的文件,关闭窗口; 1gcc ./main.c #使用gcc编译指令编译和链接刚才写好的.c文件 此时在此文件下生成了一个a.out可执行文件 linux下文件的类型识别不以后缀名为判断依据 执行这个可执行文件: 1./a.out 2020.04.05头文件: 1# include &lt;头文件&gt; // 常用的有stdio.h(输入输出函数), math(数学函数)和string.h(字符和字符串函数)等 创建并编写test02.c文件 12345678910111213141516171819#include &lt;stdio.h&gt;int m;int min(int x,int y);void main(){ int a, b; printf(\"\\nEnter two Numbers:\"); scanf(\"%d,%d\",&amp;a,&amp;b); m = min(a,b); printf(\"Minimum:%d\\n\",m);}int min(int x,int y){ int t = 0; if(x&lt;y){ t = x; }else{ t = y; } return(t);} 编译链接: 1gcc ./a.out 执行: 12345678rxz@mengjianmingri:~/myC/test01$ ./a.out Enter two Numbers:45,78Minimum:45rxz@mengjianmingri:~/myC/test01$ ./a.out Enter two Numbers:74,12Minimum:12 c语言结构特点总结: 一个c语言源程序由一个或多个源文件组成 每个源文件可以由一个或多个函数组成 一个源程序不论由多少文件组成,都有且只能有一个main()函数 源程序中可以有预处理命令(#include命令仅为一种),预处理命令通常应放在源文件或源程序的最前面 每一个说明每一个语句都必须以分号结尾,但预处理命令,函数头和大括号之后不能加分号 关键字,标识符之间必须至少加上一个空格以示间隔,若有明显的间隔府,也可以不再加空格来间隔 C语言的数据结构在c语言之中数据结构可分为四大类:基本数据类型,构造数据类型,指针数据类型和空类型 基本数据类型: 其值不可再分解为其他数据类型,即是自我说明的(整型,字符型,实型(单精度和双精度),枚举型) 构造数据类型: 由基本数据类型和其他构造数据类型复合而成(数组型,结构体型,共用体型) 指针类型: 特殊且重要 ,指针的值用来表示某个变量在内存中的地址,指针变量的取值类似整型,但二者是完全不同的量 空类型: 所有基本数据类型的基础,在调用函数值时,通常向调用者返回一个函数值,但有的函数不需要向调用者返回函数值,这种函数可被定义为空类型,类型说明符为void #define 是一条预处理命令(预处理命令都以”#”开头),称为宏定义命令(在后面预处理程序中将进一步介绍),其功能是把一个标识符定义为其后的常量值。一经定义,以后在程序中所有出现该标识符的地方均代之以常量值。#define 语句不以分号结尾,它可以被放于源代码的任何位置。不过在定义常量时,只有在它定义之后的源代码中,它才有效。 如: 1#define MM 111111 //将常量值111111用字符常量MM来代替 const关键字 其实跟java中的final很类似 如: 1const float pi = 3.1415926 //因为有效位数的限制,后三位不起作用,且pi此时可以看成一个不可再被修改的常量 2020.04.06C语言中的变量: 全局变量 局部变量 静态变量(又分为静态局部变量和静态全局变量) 数据类型变量(即char int float等修饰的变量) 寄存器变量,修饰字符是register 外部变量,修饰字符是 extern 编写test03.c并编译执行(根据输入的数值作为圆的半径从而计算圆的周长和面积): 12345678910111213#include &lt;stdio.h&gt;#define PI 3.14void main(){ float r,area,circ; printf(\"\\nenter a num :\"); scanf(\"%f\",&amp;r); circ=PI*(2*r); area=PI*(r)*(r); printf(\"chang:%f\",circ); printf(\"\\n\"); printf(\"area:%f\",area); printf(\"\\n\");} 整型常量的表示形式整型常量即整型常数,在 C 语言中的地位十分重要。在 C 语言中,可以使用如下 3 种形式来表示整型常量: 八进制整型常量 八进制整型常量必须以 0 开头,即以 0 作为八进制数的前缀,其取值范围为 0~7。八进制数通常是无符号数。以下各数是合法的八进制数:015(十进制为 13),0101(十进制为 65),0177777(十进制为 65535)。 十六进制整型常量 十六进制整型常量的前缀为 0X 或 0x,其取值范围为 09,AF 或 a~f。以下各数是合法的十六进制整型常量:0X2A(十进制为 42),0XA0 (十进制为 160),0XFFFF (十进制为 65535)。而以下各数不是合法的十六进制整型常量:5A (无前缀 0X),0X3H (含有非十六进制数)。 十进制整型常量 十进制整型常量没有前缀,其取值范围为 0~9。以下各数是合法的十进制整型常量:237,-568,65535,1627。而以下各数不是合法的十进制整型常量:023 (不能有前导 0),23D (含有非十进制数)。 C语言复习小节(已三天)其实java学透了再回过头来学C就觉得格外容易,尤其是大一的时候还学过一年,更多的就是复习,也希望自己能坚持继续复习!感谢祖师爷们赏饭吃!","link":"/2020/04/04/linux-%E4%B8%8B%E5%A4%8D%E4%B9%A0c%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E6%97%A5%E8%AE%B0-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"title":"linux下压缩和解压缩指令","text":"关于压缩和解压缩命令之前在win10时把所有本地歌曲压缩成了zip包放到了移动硬盘里备了份,足足有9个G,昨天在ubuntu18.04下想用图形化直接解压到网易云的音乐存储目录,但解压出来的歌曲的所有信息全都变成了乱码,但歌曲播放还是正常的,显然这是编码解码不一致造成的 ,因为图形化解压没法指定字符集,因此还是使用了命令行来解决了这个问题,同时把在网上查到的一些比较全的压缩解压缩指令记个笔记; 如何解决的我这个问题:1unzip -O GBK *.zip # GBK为你要指定的解码字符集,要与压缩时的字符集对应上才不会乱码,win下压缩的多为GBK编码 其他压缩解压命令 以下转自 https://blog.csdn.net/u014704496/article/details/38944567 1:tar tar [-cxtzjvfpPN] 文件与目录 …. 参数： -c ：建立一个压缩文件的参数指令(create 的意思)； -x ：解开一个压缩文件的参数指令！ -t ：查看 tarfile 里面的文件！ 特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！ 因为不可能同时压缩与解压缩。 -z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？ -j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？ -v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！ -f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！ 例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成 『 tar -zcvPf tfile sfile』才对喔！ -p ：使用原文件的原来属性（属性不会依据使用者而变） -P ：可以使用绝对路径来压缩！ -N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中！ –exclude FILE：在压缩的过程中，不要将 FILE 打包！ 范例： 范例一：将整个 /etc 目录下的文件全部打包成为 /tmp/etc.tar [root@linux ~]# tar -cvf /tmp/etc.tar /etc 范例二：查阅上述 /tmp/etc.tar.gz 文件内有哪些文件？ [root@linux ~]# tar -ztvf /tmp/etc.tar.gz # 由于我们使用 gzip 压缩，所以要查阅该 tar file 内的文件时， # 就得要加上 z 这个参数了！这很重要的！ 范例三：将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下 [root@linux ~]# cd /usr/local/src [root@linux src]# tar -zxvf /tmp/etc.tar.gz # 在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说， # 我先将工作目录变换到 /usr/local/src 底下，并且解开 /tmp/etc.tar.gz ， # 则解开的目录会在 /usr/local/src/etc 呢！另外，如果您进入 /usr/local/src/etc # 则会发现，该目录下的文件属性与 /etc/ 可能会有所不同喔！ 范例四：在 /tmp 底下，我只想要将 /tmp/etc.tar.gz 内的 etc/passwd 解开而已 [root@linux ~]# cd /tmp [root@linux tmp]# tar -zxvf /tmp/etc.tar.gz etc/passwd # 我可以透过 tar -ztvf 来查阅 tarfile 内的文件名称，如果单只要一个文件， # 就可以透过这个方式来下达！注意到！ etc.tar.gz 内的根目录 / 是被拿掉了！ 范例五：将 /etc/ 内的所有文件备份下来，并且保存其权限！ [root@linux ~]# tar -zxvpf /tmp/etc.tar.gz /etc # 这个 -p 的属性是很重要的，尤其是当您要保留原本文件的属性时！ 范例六：在 /home 当中，比 2005/06/01 新的文件才备份 [root@linux ~]# tar -N “2005/06/01” -zcvf home.tar.gz /home 范例七：我要备份 /home, /etc ，但不要 /home/dmtsai [root@linux ~]# tar –exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc 范例八：将 /etc/ 打包后直接解开在 /tmp 底下，而不产生文件！ [root@linux ~]# cd /tmp [root@linux tmp]# tar -cvf - /etc | tar -xvf - # 这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！ # 要注意的地方在於输出档变成 - 而输入档也变成 - ，又有一个 | 存在～ # 这分别代表 standard output, standard input 与管线命令啦！ 2:gunzip gunzip(gnu unzip) 功能说明：解压文件。 语 法：gunzip [-acfhlLnNqrtvV][-s ][文件…] 或 gunzip [-acfhlLnNqrtvV][-s ][目录] 补充说明：gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为”.gz”。 事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。 参 数： -a或–ascii 使用ASCII文字模式。 -c或–stdout或–to-stdout 把解压后的文件输出到标准输出设备。 -f或-force 强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 -h或–help 在线帮助。 -l或–list 列出压缩文件的相关信息。 -L或–license 显示版本与版权信息。 -n或–no-name 解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽略不予处理。 -N或–name 解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。 -q或–quiet 不显示警告信息。 -r或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -S或–suffix 更改压缩字尾字符串。 -t或–test 测试压缩文件是否正确无误。 -v或–verbose 显示指令执行过程。 -V或–version 显示版本信息。 3:gzip gzip命令 关键词： gzip gzip命令 减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。 gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。 语法：gzip [选项] 压缩（解压缩）的文件名 各选项的含义： -c 将输出写到标准输出上，并保留原有文件。 -d 将压缩文件解压。 -l 对每个压缩文件，显示下列字段： 压缩文件的大小 未压缩文件的大小 压缩比 未压缩文件的名字 -r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。 -t 测试，检查压缩文件是否完整。 -v 对每一个压缩和解压的文件，显示文件名和压缩比。 -num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。 系统缺省值为6。 假设一个目录/home下有文件mm.txt、sort.txt、xx.com。 例1：把/home目录下的每个文件压缩成.gz文件。 $ cd /home $ gzip * $ ls m.txt.gz sort.txt.gz xx.com.gz 例2：把例1中每个压缩的文件解压，并列出详细的信息。 $ gzip -dv * mm.txt.gz 43.1%—–replaced with mm.txt sort.txt.gz 43.1%—–replaced with sort.txt xx.com.gz 43.1%—–replaced with xx.com $ ls mm.txt sort.txt xx.com 例3：详细显示例1中每个压缩的文件的信息，并不解压。 $ gzip -l * compressed uncompr. ratio uncompressed_name 277 445 43.1% mm.txt 278 445 43.1% sort.txt 277 445 43.1% xx.com $ ls mm.txt.gz sort.txt.gz xx.com.gz 例4：压缩一个tar备份文件，如usr.tar，此时压缩文件的扩展名为.tar.gz $ gzip usr.tar $ ls usr.tar.gz 4:unzip命令 用MS Windows下的压缩软件winzip压缩的文件如何在Linux系统下展开呢？可以用unzip命令，该命令用于解扩展名为.zip的压缩文件。 语法：unzip [选项] 压缩文件名.zip 各选项的含义分别为： -x 文件列表 解压缩文件，但不包括指定的file文件。 -v 查看压缩文件目录，但不解压。 -t 测试文件有无损坏，但不解压。 -d 目录 把压缩文件解到指定目录下。 -z 只显示压缩文件的注解。 -n 不覆盖已经存在的文件。 -o 覆盖已存在的文件且不要求用户确认。 -j 不重建文档的目录结构，把所有文件解压到同一目录下。 例1：将压缩文件text.zip在当前目录下解压缩。 $ unzip text.zip 例2：将压缩文件text.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。 $ unzip -n text.zip -d /tmp 例3：查看压缩文件目录，但不解压。 $ unzip -v text.zip 6:zgrep命令 这个命令的功能是在压缩文件中寻找匹配的正则表达式，用法和grep命令一样，只不过操作的对象是压缩文件。 如果用户想看看在某个压缩文件中有没有某一句话，便可用zgrep命令。","link":"/2020/04/02/linux%E4%B8%8B%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4/"},{"title":"linux基础指令学习","text":"mkdir 创建目录1mkdir myTest/test02 -p -p 递归地建立目录,即可以一次建立多层目录 -m 创建目录的时候直接设定权限 rmdir 删除目录(空文件夹)1rmdir myTest/test02 -p -p 递归删除此文件夹 ls 档案和目录的检视12345678ls [-aAdfFhilRS] 目录名称ls [--color={none,auto,always}] 目录名称ls [--full-time] 目录名称 #例子如下ls -al ~ #列出所有文件夹及文件,包括隐藏文件和文件属性ls -alF --color=never ~ #不显示颜色,但在文件名末显示出该文件名代表的类型 ls -al --full-time ~ #完整呈现文件的修改时间 #同时,ll就相当于ls -l -a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～-d ：仅列出目录本身，而不是列出目录内的档案数据-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！)-F ：根据档案、目录等信息，给予附加数据结构，例如： *：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案；-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来；-i ：列出 inode 位置，而非列出档案属性；-l ：长数据串行出，包含档案的属性等等数据；-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID 与 GID 会在账号管理提到！)-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；-R ：连同子目录内容一起列出来；-S ：以档案容量大小排序！-t ：依时间排序–color=never ：不要依据档案特性给予颜色显示；–color=always ：显示颜色–color=auto ：让系统自行依据设定来判断是否给予颜色–full-time ：以完整时间模式 (包含年、月、日、时、分) 输出–time={atime,ctime} ：输出 access 时间或 改变权限属性时间 (ctime)而非内容变更时间 (modification time) cp 复制,建立链接,比对1cp [-adfilprsu] 复制源 粘贴处 -a ：相当于 -pdr 的意思；-d ：若来源文件为连结文件的属性(link file)，则复制连结文件属性而非档案本身；-f ：为强制 (force) 的意思，若有重复或其它疑问时，不会询问使用者，而强制复制；-i ：若目的檔(destination)已经存在时，在覆盖时会先询问是否真的动作！-l ：进行硬式连结 (hard link) 的连结档建立，而非复制档案本身；-p ：连同档案的属性一起复制过去，而非使用预设属性；-r ：递归持续复制，用于目录的复制行为；-s ：复制成为符号连结文件 (symbolic link)，亦即『快捷方式』档案；-u ：若 destination 比 source 旧才更新 destination ！ rm 删除目录或文件1rm [-fir] 文件或目录 -f ：就是 force 的意思，强制移除；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除啊！最常用在目录的删除了 mv 移动目录或文件(剪切)1mv [-fiu] 目录或文件名 -f ：force 强制的意思，强制直接移动而不询问；-i ：若目标档案 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标档案已经存在，且 source 比较新，才会更新 (update) 文档查看除去最常用的cat more less 外head 和 tail的用法:12head -n 10 文件名 #显示文件的前十行tail -n 20 文件名 #显示文件的后20行 file 查看文件的类型1file 文件名 #文件的类型,例如二进制或data 文件的 查找which1which 文件名 [-a] #-a是将所有符合条件的结果均列出 whereis1whereis [-bmsu] 文件名 -b :只找 binary 的档案-m :只找在说明文件 manual 路径下的档案-s :只找 source 来源档案-u :没有说明档的档案 locate1locate 部分文件名 #locate 指令类似模糊查询 find1find / -name passwd #find指令的参数较复杂,这条范例是查找文件名为 passwd 的文件 压缩文件处理compress *.Z文件(很少使用)123compress 文件名 #压缩此文件成*.Z格式compress -d 文件名 #解压此文件(前提是此文件是*.Z文件)compress -c 文件1 &gt; 文件2 #将文件1压缩为文件2的同时保留文件1 gzip,zcat *.gz 文件1234gzip 文件1gzip -d 文件2zcat 文件2 #读取文件2解压后的内容gzip -9 -c man.config &gt; man.config.gz #-9压缩速度最慢但压缩后空间最小 ,-1反之,在1到9之间取值 bzip2,bzcat *.bz2 文件1bzip2 文件1 #所有参数同上 tar12tar [-cxtzjvfpPN] 文件夹或文件tar -zxvf *.tar.gz -c ：建立一个压缩档案的参数指令(create 的意思)；-x ：解开一个压缩档案的参数指令！-t ：查看 tarfile 里面的档案！ 特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！ 因为不可能同时压缩与解压缩。-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？-v ：压缩的过程中显示档案！这个常用，但不建议用在背景执行过程！-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！ 例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成 『 tar -zcvPf tfile sfile』才对喔！-p ：使用原档案的原来属性（属性不会依据使用者而变）-P ：可以使用绝对路径来压缩！-N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的档案中！–exclude FILE：在压缩的过程中，不要将 FILE 打包,即排除某个文件","link":"/2020/03/30/linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/"},{"title":"九种经典排序算法","text":"吸取了去年字节跳动面试时在算法上的惨痛教训后,今年春招那一阵我也是恶补算法,首先攻克的就是九种经典排序算法: 选泡插 快归堆希桶计基 我先把我当时安排完这九种算法后写的心得po在下面,之后也会继续复习着算法长期更新此文至复习完 我当时写的这九种算法的完整代码的仓库: https://github.com/Mengjianmingri/myAlgorithm 当然,是java,毕竟还是要吃高斯林祖师爷赏的这口饭 选择排序:1最简单也最没用,即一遍遍的过滤数组,找到最小的数和最前面做交换;单指针记录此次遍历中最小值的索引; 冒泡排序:1两两比较,后一个数比前一个数大就做交换,同样是单指针,也是没用的算法; 插入排序:1即从索引1处开始和前面的数做比较找到当前它应该在的位置,移位,就是摸扑克排顺序的过程,在简单排序中最常用; 希尔排序:1基于插入排序,可以看作多线程版插排,即设置一个步长,每一轮比较步长间隔处的数,使用插排;特点是间隔大移动次数少,间隔小移动距离短(移位法); 归并排序:12345671.使用递归思想,把数组分为左右两部分,假设左右两部分都是有序的,然后继续往下假设直到分成子数组只有一个数或两个数;2.现在子数组有序了,此时分配一个新数组,长度等于两个子数组长度和,定义三个指针,左指针指第一个子数组的最左边,右指针指向第二个子数组的最左边 第三个指针指向新数组的最左边,比较这两个指针处的值,把更小的那个值赋给新数组指针处,同时移动左右指针中指向更小值的那个指针和新数组指针 直到左右指针中其中一个移到了它的最大值,这时把另一个没达到最大值的左右指针后面的数直接按顺序赋给新数组指针处,直到新数组指针到达最大值 此时左右两个指针也都到达了各自的最大值,此次归并结束,把新数组赋值回原数组对应位置(即从左指针到右指针能移动到的最大值处)3.编写递归方法,分四步:(1)把当前数组分为两部分;(2)左边排序;(3)右边排序;(4)归并排序;4.归并排序是java对象的默认排序算法(要经过判断),可以实现稳定排序,最好最坏时间复杂度都是O(N*logN),个人觉得是比较完美的一种算法; 快速排序:12345671.使用递归思想,选定一当前数组中的数当轴,然后把当前数组排序成轴左边都比轴小,右边都比轴大,然后轴左右两边的数组再各自选定一个轴,排序,递归下去;2.经典单轴快排:选定当前数组最后一个数做轴,设置左右两个指针,左指针指向当前数组最左端,右指针指向轴处索引减一,左右指针 不断向中间靠近,左指针遇到比轴大的数停下,右指针遇到比轴小的数停下,只有在左右指针同时停止时,交换左右指针指向的值,然后左右指针继续向中间靠近,当左右指针变为相邻那一刻时,停止左右指针变化且不交换对应值,把右指针处值和轴做交换,一次快排结束3.编写递归方法,分四步:(1)选定一个轴[轴的选取直接影响快排的时间复杂度]; (2)对当前数组快速排序,确定轴应该在的位置;(3)轴左边排序;(4)轴右边排序;4.快速排序的轴选定很重要,直接影响时间复杂度,平均时间复杂度和最好时间复杂度都是O(N*logN),最坏时间复杂度是O(N^2) 快排是不稳定的; 计数排序:123456桶思想算法,但局限性较大,即首先要确定当前数组中值的取值范围,定义一个按照这个范围的长度的新数组,遍历原数组,把遍历出的值对应到新数组的索引,把新数组此索引处值加一;遍历完原数组后,定义一个指针指向新数组索引为1处,把此处的值变为指针前一个索引处的值和自己的值的和,向后移动指针,创建一个最终数组长度等于原数组,倒着遍历原数组的值,把这个值对应成新数组索引并拿到新数组这个索引处的值(并对这个新数组的值进行减减操作),这个值减一就是原数组值在最终数组中应该放入的位置遍历完原数组,最终数组里就是排序好的原数组,并且是稳定的;如果不要求稳定性则不需要累加新数组而且最后不需要倒着遍历原数组,实现简单很多,具体见代码 基数排序:1234基数排序也是桶思想,创建一个二维数组作为桶,一维索引长度等于原数组最大值的位数(就是几位数)遍历原数组,按位数的值存入桶,并设置一个新数组长度等于最大位数记录桶的对应一维索引处放了几个值,遍历完再把桶里的数据按照新数组里的值拿出来放回原数组,然后置空新数组;接下来提高位数再次遍历原数组,思路和实现都简单;桶排序思想实质上是用空间换时间; 桶排序:1用的很少,也要先确定原数组值的取值范围,把这个范围分成几份,每份对应一个桶,遍历原数组存入对应的桶,遍历完后再在每个桶内部排序后取出;","link":"/2020/04/06/%E4%B9%9D%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"《卡拉马佐夫兄弟》读书笔记","text":"有幸能静下心来研读陀翁的书,相信俄国文学能让我学会更多; 《卡拉马佐夫兄弟》是一部读起来很不轻松的书，但译者必须千方百计让人读得下去，而且尽可能读懂。在此我不敢侈谈什么形似神似、原汁原味之类的高境界。许多读者知道这是世界文学的一座高峰、一颗明珠，但尝试阅读又半途而废的大有人在。如果这个译本的读者中坚持读完的人数比重较之过去有所增长，那就意味着我实现了自己追求的目标。 荣如德 2020.04.09","link":"/2020/04/07/%E3%80%8A%E5%8D%A1%E6%8B%89%E9%A9%AC%E4%BD%90%E5%A4%AB%E5%85%84%E5%BC%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C","slug":"C","link":"/tags/C/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"俄国文学","slug":"俄国文学","link":"/tags/%E4%BF%84%E5%9B%BD%E6%96%87%E5%AD%A6/"},{"name":"陀思妥耶夫斯基","slug":"陀思妥耶夫斯基","link":"/tags/%E9%99%80%E6%80%9D%E5%A6%A5%E8%80%B6%E5%A4%AB%E6%96%AF%E5%9F%BA/"},{"name":"《卡拉马佐夫兄弟》","slug":"《卡拉马佐夫兄弟》","link":"/tags/%E3%80%8A%E5%8D%A1%E6%8B%89%E9%A9%AC%E4%BD%90%E5%A4%AB%E5%85%84%E5%BC%9F%E3%80%8B/"}],"categories":[{"name":"C语言","slug":"C语言","link":"/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"linux shell","slug":"linux-shell","link":"/categories/linux-shell/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}